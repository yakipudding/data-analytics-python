---
title: 'リスト・イテラブル・集合'
---

## リスト
- 最後の要素のインデックスは-1になるので注意
- スライシングの最後の要素も含まないため注意

```py
# 作成
li = [0, 1, 2, 3, 4]

# インデックス
li[0]
# 0

# インデックス：要素に後ろからアクセス（-1が末尾の要素）
li[-2]
# 3

# 追加
li.append(5)
```

### 要素数
```py
len(li)
# 5
```

### 検索
```py
# 要素があるかどうか
3 in li

# 要素のindex
li.index(3)
# 3
```

### スライシング
```py
# スライシング（最後の要素は含まない）
li[0:2]
# [0, 1] インデックス0から(2-1)の要素まで

li[:-1]
# [0, 1, 2, 3] インデックス0から[末尾の要素の1個手前]まで

# step
li[::2]
# [0, 2, 4] 2こ飛ばし

li[::-1]
# [4, 3, 2, 1, 0] 飛ばさずに順序を逆にしている
```

### リスト内包表記
```py
[item*2 for item in li]
# [0, 2, 4, 6, 8]

# 条件付き
[l for l in [2,5,4,7,1,3] if l < 3]
# [2, 1]
```

### 合計
True/Falseのリストの場合、True(=1)の数になる
```py
sum(li)
# 10
```

### 結合
リスト結合(concat)は+
```py
[0, 1] + [2, 3, 4]
# [0, 1, 2, 3, 4]
```

## イテラブル
### [range](https://docs.python.org/ja/3/tutorial/controlflow.html#the-range-function)
- 連続した数値リストを生成する
  - イテレータや自動生成データに使う
- **rangeやスライスは最後の要素は対象に含まないので注意**
  - 0始まりで要素数を指定しているイメージ
  - 0始まりでなくても、要素数は`stop - start`で計算できる

```py
# 0からend-1までの整数からなるリストを作成する
[r for r in range(0, 10)]
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# startからend-1までの整数からなるリストを作成する
[r for r in range(2, 10)]
# [2, 3, 4, 5, 6, 7, 8, 9]

# startからend-1までのstep(第三引数)で指定された値だけ増加するリストを作成する
[r for r in range(0, 10, 3)]
# [0, 3, 6 ,9]
```

### indexも取得したいときはenumerate
range使ってもよいがenumerate使えるなら使ったほうが良い
```py
for i, d in enumerate(['a','b','c']):
  print(f'{i}: {d}')
# 0: a
# 1: b
# 2: c
```

### 2つ一緒に回したいときはzip
要素数が合わないときは短いほうに合わせてループが止まるので注意
```py
for i, j in zip([0, 1, 2], ['a', 'b', 'c']):
  print(f'{i}, {j}')
# 0, a
# 1, b
# 2, c
```

## 集合
## 要素の重複削除をしたいときはset
- 特徴
  - （重複しない）要素の集合を扱う
  - set同士の集合演算ができる
    - `set([1,2,3]) - set([1,2]) = set([3])`
- 同じ要素を追加しても要素が増えないため、要素の重複削除に用いられることが多い

```py
set([0, 0, 0, 1, 2, 3, 3])
# {0, 1, 2, 3}
```

## ユニークな要素ごとにカウントしたいときはCounter
```py
from collections import Counter
count = Counter([0, 0, 0, 1, 2, 3, 3])
# Counter({0: 3, 1: 1, 2: 1, 3: 2})
# 最頻値
counter.most_common(1)
# [(0, 3)]
```
